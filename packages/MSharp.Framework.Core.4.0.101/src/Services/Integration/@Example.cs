//namespace MSharp.Framework.Services.Integration.Example
//{
//    // Note: This is a service implementation example.
//    // MyService can be replaced by a proper name depending on your project's requirements.

//    /// <summary>
//    /// This simple class will not have any implementation body. It's used to invoke the service.
//    /// </summary>
//    class MyService : IntegrationService<MyServiceRequest, MyServiceResponse> { }

//    /// <summary>
//    /// A basic C# class to contain all parameters which are logically part of your application.
//    /// Do not add properties which are used only to establish the pipelines such as constant security keys, access tokens, etc.
//    /// This class should be minimal and only represent what has a meaning in yoru application's domain for the purpose of integration.
//    /// </summary>
//    class MyServiceRequest
//    {
//        public string Param1, Param2;
//    }

//    /// <summary>
//    /// Same as MyServiceRequest, it should only have data fields that are relevant to the domain of your application.
//    /// Keep it pure and simple. It can have a full hierarchy such as List classes, nested objects, etc.
//    /// </summary>
//    class MyServiceResponse
//    {
//        public string Ourcome1, Ourcome2;
//    }

//    namespace My.VSProject
//    {
//        /// <summary>
//        /// The actual service implementation. Keep it in a separate DLL (project).               
//        /// Your Model project should not reference this DLL, but your website project should.
//        /// This dll should reference your Model dll.
//        /// It should be self sufficient class that can work simply from ServiceRequest and web.config data.
//        /// </summary>
//        class MyServiceImplementor : IServiceImplementor<MyServiceRequest, MyServiceResponse>
//        {
//            /// <summary>
//            /// In this method, write the actual implementation. Make calls to the external web service, Http, etc.
//            /// You can use any set of implementation classes for this, including those typically generated by WSDL utilities.
//            /// You can make several calls to the external service, establish security, read from web.config, etc.
//            /// At the end of the process, the final relevant information should be written into an instance of MyServiceResponse and returned.
//            /// </summary>
//            public MyServiceResponse GetResponse(MyServiceRequest request)
//            {
//                // Dirty work goes here.
//                // ...
//                return new MyServiceResponse { Ourcome1 = "sample", Ourcome2 = "sample" };
//            }
//        }
//    }

//    class Website
//    {
//        public void Global_ASAX()
//        {
//            // The actual service implementation will be registerd here once for live use (non-test mode).
//            // Throughout the development period when the application is in TDD mode, this service is essentially not registered, so
//            // there is no dependency on the external service.

//            // Perhaps only once when the ServiceImplementation is created during development cycle,
//            // you can remove the condition to test it once or twice.            
//            if (WebTestManager.IsTddExecutionMode() == false)
//            {
//                MyService.RegisterImplementor<My.VSProject.MyServiceImplementor>();

//                // Optional: Add an Automated Task to call the following.
//                // It will frequently process all outstanding items in the queue.
//                // Mainly relevant for multi-try situations in live operations. Avoid unless necessary.
//                IntegrationManager.ProcessOutstandingItems();
//            }
//            else
//            {
//                // Note: In case you need to provide a Mock implementation for the service, instead of manually injecting the responses
//                // through sanity, you can create a class that fakes responses to requests and inject it here:
//                // e.g: MyService.Register<My.VSProject.MyServiceMockImplementation>();
//            }
//        }
//    }

//    class Model
//    {
//        internal void SomeBusinessLogicMethod()
//        {
//            // In the consumer classes (mostly in your Model project), all requests to the integration services will be via the following method.
//            // Note: The following method will serialize the request and insert it in the IntegrationQueueItem table.
//            // It will then wait for the response to be provided.

//            // In TDD mode, the ServiceImplementation will not have been registered, and therefore this call will wait indefinitely for a response.
//            // In practice, whilst this method is waiting for the response, the idea is that you manually go to the Database and inject the response
//            // in the Queue. As soon as the response is provided, the waiting method will then pick the result and proceed.

//            // In Sanity there is a command called "$check integartion queue" used to manually inject the response.

//            var result = MyService.Request(new MyServiceRequest { Param1 = "1", Param2 = "X" });
//        }
//    }

//    class UnitTest
//    {
//        public void UnitTest_For_Business_Logic_Layer()
//        {
//            // When the service consumer unit (business logic layer) is invoked, it will in turn insert its IntegrationQueueItem and wait for its response.
//            // So instead of directly calling the method in your Unit Test, you should invoke that in a Task.
//            var app = new Model();
//            var task = new System.Threading.Tasks.Task(app.SomeBusinessLogicMethod);
//            task.Start();

//            // At this stage the logic unit is waiting for the response. So here we just inject a response, so the unit will continue then.
//            var assumedResponse = new MyServiceResponse { Ourcome1 = "Something", Ourcome2 = "anything" };
//            MyService.InjectResponse(assumedResponse);

//            // At this stage, the MyService.Request() called inside the logic unit, will come out of freezing and return the injected 
//            // response to the consumer unit.

//            task.Wait();

//            // Note: This way, the dependency to the external service is bypassed by manually injecting the response.
//        }
//    }
//}